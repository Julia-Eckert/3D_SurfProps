
clear all

% ......................................................................
% .............. Orientation Detection of 3D Surfaces ..................
% ......................................................................

% Author: Julia Eckert (j.eckert@imb.uq.edu.au)
% Date: 2025-5

% --- DESCRIPTION: 
% This code performs the 3D surface analysis via slicing the systems 
% surface by shallow slices, i.e. translated tangent planes, and 
% reconstructing the orientation field of the cells.

% --- TO DO: 
% ImageJ/Fiji
%   Image for orientation analysis
%       - pre-process image as explained in REF
%       - invert z-stack (background = white) 
%       - save z-stack as 'Orientation_Ch.tif'

% --- INPUT:
% MATLAB ... output of pre-analysis file: SurfacePoints.mat (i.e. generated by Surface_Points.m)
%   SurfacePoints.xyz             ... xyz surface point positions on surface, in um 
%   SurfacePoints.xyzNormal       ... xyz normal vectors  
%   SurfacePoints.Pixel           ... xyz dimension of z-stack, in um/pix
%   SurfacePoints.GridDistance    ... distance between xyz surface points, in um
% Images z-stack as TIF-format
%   Mask_Boundary.tif             ... z-stack of black-and-white mask
%   Orientation_Ch.tif            ... z-stack of multicellular system (inverted, background=white)

% Additional codes required:
% Download 'ij.jar' and 'mij.jar' plugins and install in FIJI, see here: https://github.com/dasv74/mij

% PLEASE UNCOMMEND and change path to plugins: 
javaaddpath('.../ij.jar');                      % for Mac
javaaddpath('.../mij.jar');
% OR:
%javaaddpath('...\ij.jar');                      % for Windows
%javaaddpath('...\mij.jar');

% PLEASE UNCOMMEND and change path to Fiji scripts to access 'Miji.m', see also: https://imagej.net/plugins/miji
addpath('.../Applications/Fiji.app/scripts')    % for Mac
% OR:
%addpath('...\Fiji.app\scripts')                 % for Windows


% intensity average over x planes translated towards the bulk ... 
% ... 0 corresponds to the tangent plane at the surface point
no_tang_plane = 5;          % aggregate
%no_tang_plane = [0:1:3];    % Zebrafish heart 

% coarse-graining radius: radius = cg_range * W ... with W = d_P/2 and d_P is ...
% ... the distance between xyz surface points, in um 
cg_range = 2;         


% --- OUTPUT:
% save as Analysis_Surface_Nematic.mat

% nematic director analysis per surface point, k_point:
% Nematic(k_point).xyz_director_pos         ... xyz position of surface points, in um
% Nematic(k_point).xyz_normal_vector        ... xyz normal vectors
% Nematic(k_point).theta                    ... theta angle of plane, in degree
% Nematic(k_point).phi                      ... phi angle of plane, in degree
% Nematic(k_point).Nematic_director_comp    ... 2D complex nematic order 
% Nematic(k_point).xy_Nematic_director      ... xy nematic directors 

% plane analysis:
% Properties.x_system_center                ... x cell system center point, in um
% Properties.y_system_center                ... y cell system center point, in um
% Properties.z_system_center                ... z cell system center point, in um
% Properties.grid_dis_3D                    ... distance between xyz surface points, in um
% Properties.range_tangent_planes           ... distance of plane to surface, in um
% Properties.coarse_graining_range          ... coarse-graining 
%                                               range n*W = n*d_P/2 (see manuscript, Eq.(4))


%..........................................................................
%........................ Main ............................................
%..........................................................................

% suppresses graphical output, speeds up the analysis
%set(0,'DefaultFigureVisible','off')

% ... Upload images .......................................................

image_Orientation_Ch = tiffreadVolume('Orientation_Ch.tif'); % see (1) above   
image_mask = tiffreadVolume('Mask_Boundary.tif');               


% ... load information of surface points and normal vectors ..............
load('SurfacePoints.mat')
if isempty(SurfacePoints.Pixel) == 1
    disp(['SurfacePoints.mat does not exist']);
end
xyz_pos = SurfacePoints.xyz;              %... xyz position of surface points, in um
xyz_normal_vec = SurfacePoints.xyzNormal; %... xyz normal vectors
xyz = SurfacePoints.Pixel;                %... dimension of z-stack, um/pix
grid_dis_3D = SurfacePoints.GridDistance; %... distance between xyz surface points, in um


% ... Set parameters for analysis ... can be adjusted ..................... 

% grid distance of nematic director on 2D plane, pre-set to half of the 3D
% grid distance, in um
grid_distance = grid_dis_3D/2; 

% plane radius in um ... size: plane_r*2 x plane_r*2, in um
plane_r = 50; 

% window size for averaging the orientation-output of OrientationJ, in pix
window_size = grid_distance/(2*plane_r/1000); % in pix (= grid_distance / 2*plane_r/1000 um/um/pix)

% window of overlap for nematic director calculation, in pix 
ol = window_size/4; 

% length nematic director, in pix
scale_factor = window_size/2;


% ... Get dimensions for xyz plane ........................................ 

% create xyz meshgrid for spheroid slicing 
xlin = 0:xyz(2):size(image_Orientation_Ch,2)*xyz(2)-xyz(2);
ylin = 0:xyz(1):size(image_Orientation_Ch,1)*xyz(1)-xyz(1);
zlin = 0:xyz(3):size(image_Orientation_Ch,3)*xyz(3)-xyz(3);
[xdata, ydata, zdata] = meshgrid(xlin,ylin,zlin);

% dimensions of meshgrid data 
xmin = min(xdata(:));
xmax = max(xdata(:));
ymin = min(ydata(:));
ymax = max(ydata(:));
zmin = min(zdata(:));
zmax = max(zdata(:));


% ... Pre-process stack and get properties of the cell system .............

% remove background using mask by setting values to NaN
image_Orientation_Ch = double(image_Orientation_Ch);
image_Orientation_Ch(image_mask==0) = NaN;

vdata = double(image_Orientation_Ch);

% get center of mass of cell system in xy
sm  = regionprops(bwconncomp(imfill(image_mask(:,:,round(size(image_mask,3)/2)),'holes'),8),'Area','FilledArea','FilledImage','Centroid','MajorAxisLength',...
   'MinorAxisLength', 'Perimeter','Orientation','Eccentricity','PixelIdxList','PixelList');

centroids_=[sm.Centroid];
centroids_=[centroids_(1:2:end)',centroids_(2:2:end)'];

areas_ = [sm.Area];
idx_area = find(areas_==max(areas_));

% xyz center point of cell system in um
x_system_center = centroids_(idx_area,1)*xyz(1);
y_system_center = centroids_(idx_area,2)*xyz(2);
z_system_center = zmax/2;

 
% ... Slice cell system at each surface point and get nematic order ...........

Nematic = [];
Properties = [];
% slice cell system point-by-point
for k_point = 1:length(xyz_pos(:,1))    

    disp([num2str(k_point), ' of ', num2str(length(xyz_pos(:,1)))]);

    % normalize normal surface vector 
    nnP = xyz_normal_vec(k_point,:);
    nP = nnP/norm(nnP);
    nx = nP(1);
    ny = nP(2);
    nz = nP(3); 

    % xyz position of surface point 
    P_mean = xyz_pos(k_point,:);

    % calculate angle between normal vector and z-axis -> theta, ...
    % ... see manuscript Eq.(1)
    att = atan2d(norm(cross([nx(1),ny(1),nz(1)]',[0,0,1]')), ...
            dot([nx(1),ny(1),nz(1)]',[0,0,1]')); % angle to z-axis
    % Theta in degree for regression plane
    at = -att;

    % calculate angle between normal vector and xy plane -> phi, ...
    % ... see manuscript Eq.(2)
    app = -atan2d(ny,nx);
    % Phi in degree for regression plane
    ap = -app-90;


    % create tangent plane with dimensions ... 1 pix = 2*plane_r/1000 um
    figure
    hold on
    hslice = surf(linspace(-plane_r,plane_r,1000), linspace(-plane_r,plane_r,1000), zeros(1000));
 
    rotate(hslice,[1, 0, 0],at,[0 0 0])
    rotate(hslice,[0, 0, 1],ap,[0 0 0])
    
    % max-project surface planes
    im_slice_max = ones(1000,1000)*(-255);
    for ct = 1:length(no_tang_plane)
    % move plane by um towards center, in um
        rk = no_tang_plane(ct); 
        xd = get(hslice,'XData')+P_mean(1)-x_system_center-rk*nx(1);
        yd = get(hslice,'YData')+P_mean(2)-y_system_center-rk*ny(1);
        zd = get(hslice,'ZData')+P_mean(3)-z_system_center-rk*nz(1);
    
        figure, hold on
        hold on, plot3(xyz_pos(:,1)-x_system_center,xyz_pos(:,2)-y_system_center,xyz_pos(:,3)-z_system_center,'rx', 'MarkerSize', 15)
        h = slice(xdata-x_system_center, ydata-y_system_center, zdata-z_system_center, vdata, xd, yd, zd);
    
        % get plane data
        im_slice_temp = h.CData;
        im_slice_inv = imcomplement(im_slice_temp);
        
        % max intensity projection
        im_slice_max = max(im_slice_max, im_slice_inv);

    end
    im_slice = imcomplement(im_slice_max);
    % set background to NaN
    im_slice(im_slice>=255) = NaN;

    % center point of plane, in um
    x = size(im_slice,1)/2;
    y = size(im_slice,2)/2;

    figure, imagesc(im_slice)

    % save plane properties per surface point       
    Nematic(k_point).xyz_director_pos =  P_mean;    % xyz position of surface points, in um
    Nematic(k_point).xyz_normal_vector = nP;        % xyz normal vector
    Nematic(k_point).theta = at;                    % theta angle of plane, in degree
    Nematic(k_point).phi = ap;                      % phi angle of plane, in degree

    %close all


    % ... start orientation analysis ......................................
    A = uint8(im_slice);
    B = localcontrast(A, 0.1);
    im_ori = imgaussfilt(B,5);

    Miji(false);
    MIJ.createImage(im_ori)
    MIJ.run('OrientationJ Analysis', sprintf('tensor=3.0 gradient=0 hsb=on hue=Orientation sat=Coherency bri=Original-Image orientation=on radian=off color-survey=on'));
    % orientation map ...  angles in degree
    Fiji_OJ_temp = MIJ.getImage('OJ-Orientation-1');
    % color map of angles for mask
    color_map = MIJ.getImage('OJ-Color-survey-1');
    MIJ.closeAllWindows();
    MIJ.run('Close All');
    MIJ.exit();
    
    % create a mask by overlaying all color images
    tresh_mask_ori = color_map(:,:,1) + color_map(:,:,2) + color_map(:,:,3);
    seD = strel('disk',10);
    J = imdilate(tresh_mask_ori,seD);
    seD2 = strel('disk',30); 
    tresh_mask = imerode(J,seD2);
    
    s  = regionprops(bwconncomp(tresh_mask,8),'Area','FilledArea','FilledImage','Centroid','MajorAxisLength',...
       'MinorAxisLength', 'Perimeter','Orientation','Eccentricity','PixelIdxList');

    areas_ = [s.Area];

    % expand mask if nothing is detected 
    ntt = 10;
    while isempty(areas_) == 1
        tresh_mask_ori = color_map(:,:,1) + color_map(:,:,2) + color_map(:,:,3);
        seD = strel('disk',10);
        J = imdilate(tresh_mask_ori,seD);
        seD2 = strel('disk',30-ntt); 
        tresh_mask = imerode(J,seD2);
        
        s  = regionprops(bwconncomp(tresh_mask,8),'Area','FilledArea','FilledImage','Centroid','MajorAxisLength',...
           'MinorAxisLength', 'Perimeter','Orientation','Eccentricity','PixelIdxList');
        
        areas_ = [s.Area];
        
        ntt = ntt+10;
    end

    ImageMask = zeros(size(tresh_mask,1),size(tresh_mask,2));
    for ks = 1:size(s,1)
        ImageMask(s(ks).PixelIdxList) = 1;
    end    
    slice_mask = imfill(ImageMask,"holes");
    
    % remove orientation information of background of the cell system
    Fiji_OJ_temp(slice_mask==0) = NaN;
    Fiji_orientation = Fiji_OJ_temp;
    
       
    % ... nematic analysis of sub-windows .................................
        
    image_size = size(Fiji_orientation);
    bin_x = 1+ol:window_size:image_size(2)-ol;
    bin_y = 1+ol:window_size:image_size(1)-ol;
         
    Nematic_director_complex = [];
    Nematic_director = [];
    Nematic_director_pos = [];

    % get nematic order per tangent plane, see manuscript Eq.(4)
    image_selected = Fiji_orientation';
    for k = 1:length(bin_x)-1
        for l = 1:length(bin_y)-1

            % xy position of nematic director per window
            xy = [bin_x(k)+(bin_x(k+1)-bin_x(k))/2, bin_y(l)+(bin_y(l+1)-bin_y(l))/2];

            % define window 
            window_pixel = image_selected(round(bin_x(k)-ol):round(bin_x(k+1)+ol),...
                                round(bin_y(l)-ol):round(bin_y(l+1)+ol));
            window_angles = window_pixel(:);
    
            % get nematic director and complex order parameter per window,
            % ... see manuscript Eq.(4)
            [nem_direc, glob_com_vec] = get_nematic_proentation(window_angles);
            
            Nematic_director_complex = [Nematic_director_complex; glob_com_vec];    % complex order parameter
            Nematic_director = [Nematic_director; nem_direc'];                      % xy nematic director
            Nematic_director_pos = [Nematic_director_pos; xy];                      % xy position in plane in pix
        end
    end

    % get nematic director in mask
    index_yes = [];
    for kk = 1:length(Nematic_director_pos(:,1))
        if im_ori(round(Nematic_director_pos(kk,2)),round(Nematic_director_pos(kk,1))) > 0
        else
            index_yes = [index_yes; kk];
        end
    end

    Nematic_director_complex(index_yes,:) = NaN;
    Nematic_director(index_yes,:) = NaN;
    Nematic_director_pos(index_yes,:) = NaN;


    % plot nematic orientation field 
    figure
    imshow(uint8(im_ori))
    hold on
    hDefl=quiver(Nematic_director_pos(:,1),Nematic_director_pos(:,2), -scale_factor*Nematic_director(:,1), -scale_factor*Nematic_director(:,2));
    set(hDefl,...
        'Color','red',...
        'LineWidth',2,...
        'MaxHeadSize',0,...
        'AutoScale','off');
    hDefl=quiver(Nematic_director_pos(:,1),Nematic_director_pos(:,2), scale_factor*Nematic_director(:,1), scale_factor*Nematic_director(:,2));
    set(hDefl,...
        'Color','red',...
        'LineWidth',2,...
        'MaxHeadSize',0,...
        'AutoScale','off');
        
        
    % ... coarse-grain nematic director field in window_size distance .................
    % ... see manuscript Eq.(5)   

    center_point = Nematic_director_pos;
        
    % define coarse-graining binning: center of mass to image frame
    center_point_n = [image_size(1),image_size(2)]/2;
    bin = [window_size:window_size:center_point_n(:,1)];
        
    % go center point by center point
    list_glob_angle_nem = cell(length(center_point(:,1)),1);
    list_glob_mean_nem_com = cell(length(center_point(:,1)),1);
    % go center point by center point
    for m = 1:length(center_point(:,1))    
        % distance between cells and center point
        dis_center_cell = [];
        for k = 1:length(Nematic_director_pos(:,1))
            cell_pos = Nematic_director_pos(k,1:2);
            dis_center_cell = [dis_center_cell; abs(norm(cell_pos-center_point(m,:)))];
        end
        
        % sort cells according distance to center point and calculate ...
        % ... mean orientation per area
        list_glob_angle = [];
        list_glob_mean_com = [];
        
        for i = 1:length(bin)
            e = bin(i);
            % complex nematic vector in bin
            nem_bin = Nematic_director_complex(dis_center_cell<=e);
                                
            % mean of complex number
            mean_nem_bin = nanmean(nem_bin);
            list_glob_mean_com = [list_glob_mean_com; mean_nem_bin];
     
            % angle of complex mean ... angle of mean director 
            alpha1 = angle(mean_nem_bin);
            list_glob_angle = [list_glob_angle; alpha1];
        end
        
        % mean angle of director 
        list_glob_angle_nem{m,1}(:,:) = list_glob_angle;
        % averaged complex vector per grid position
        list_glob_mean_nem_com{m,1}(:,:) = list_glob_mean_com;
    end
    %close all        
        

    % ... get wanted coarse-grained orientation field ............................

    g = cg_range; % coarse-graining range
    
    figure
    imshow(uint8(im_ori))
    hold on
    grid_beta = [];
    vec_com = [];
    for h = 1:size(list_glob_angle_nem,1) 
        % angle of coarse-grained nematic director
        beta = list_glob_angle_nem{h,1}(g,1)/2;
        vec_com = [vec_com; list_glob_mean_nem_com{h,1}(g,1)];
        grid_beta = [grid_beta; beta];
        direc = [];
        direc = [cos(beta),-sin(beta)];
    
        hDefl=quiver(center_point(h,1),center_point(h,2), -scale_factor*direc(:,1), -scale_factor*direc(:,2));
            set(hDefl,...
            'Color','r',...
            'LineWidth',2,...
            'MaxHeadSize',0,...
            'AutoScale','off');
        hDefl=quiver(center_point(h,1),center_point(h,2), scale_factor*direc(:,1), scale_factor*direc(:,2));
            set(hDefl,...
            'Color','r',...
            'LineWidth',2,...
            'MaxHeadSize',0,...
            'AutoScale','off');

    end
    set(gca,'position',[0 0 1 1],'units','normalized');
    set(gca,'Visible','off');
    set(gcf,'Units','pixels');
    set(gcf,'PaperPositionMode','auto');

    dis_center_grid = [];
    for kp = 1:length(center_point(:,1))
        grid_pos = center_point(kp,1:2);
        dis_center_grid = [dis_center_grid; abs(norm(grid_pos-[x,y]))];
    end
        
    % radius to determine the director for the xy center point of the ...
    % ... tangent plane
    e = bin(1); 

    % complex nematic vector in bin
    cg_nem_vec = vec_com(dis_center_grid<=e);
                             
    % mean of complex number
    cg_mean_nem_vec = nanmean(cg_nem_vec);

    % angle of complex mean ... angle of mean director 
    cg_alpha = angle(cg_mean_nem_vec)/2;

    scale_factor = scale_factor*1.5;
    % plot xy nematic director that is used for xyz position
    cg_direc = [cos(cg_alpha),-sin(cg_alpha)];
            hDefl=quiver(x,y, -scale_factor*cg_direc(:,1), -scale_factor*cg_direc(:,2));
                set(hDefl,...
                'Color','w',...
                'LineWidth',2,...
                'MaxHeadSize',0,...
                'AutoScale','off');     
            hDefl=quiver(x,y, scale_factor*cg_direc(:,1), scale_factor*cg_direc(:,2));
                set(hDefl,...
                'Color','w',...
                'LineWidth',2,...
                'MaxHeadSize',0,...
                'AutoScale','off');         

    close all

    Nematic(k_point).Nematic_director_comp = cg_mean_nem_vec;   % complex order
    Nematic(k_point).xy_Nematic_director = cg_direc;            % xy nematic director 

end

Properties.x_system_center = x_system_center;    % x cell system center point, in um
Properties.y_system_center = y_system_center;    % y cell system center point, in um
Properties.z_system_center = z_system_center;    % z cell system center point, in um
Properties.grid_dis_3D = grid_dis_3D;            % distance between xyz surface points, in um
Properties.range_tangent_planes = no_tang_plane; % distance of plane to surface, in um
Properties.coarse_graining_range  = cg_range;    % coarse-graining range n*W = n*d_P/2

save(['Analysis_Surface_Nematic.mat'],'Nematic', 'Properties','-double')

close all


set(0,'DefaultFigureVisible','on')


% .......................................................................
% ............ Additional functions .....................................
% .......................................................................

% ... get nematic order .................................................
function [Nematic_director,glob_com_vec] = get_nematic_proentation(window_angles)
    % take angles and calculate global director 
    com_vec = [];
    angleRad = [];
    
    number = length(window_angles(:));
    for i=1:number
    
        angleRad = (window_angles(i,1)/360)*2*pi; 
    
        if angleRad >= pi/2 
            angleRad <= angleRad - pi;
        end
        if angleRad < -pi/2 
            angleRad = angleRad + pi;
        end
    
        com_vec = [com_vec; exp(1i*2*angleRad)]; 
    end      
    
    % average of complex vectors
    glob_com_vec = nanmean(com_vec);
    
    % get angle of averaged complex vector
    glob_angle = angle(glob_com_vec)/2; 
    
    % create director of window
    Nematic_director = [cos(glob_angle); -sin(glob_angle)]; 
end




