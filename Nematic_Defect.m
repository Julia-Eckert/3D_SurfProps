
clear all 

% ......................................................................
% ...................... Defect detection ..............................
% ......................................................................

% Author: Julia Eckert (j.eckert@imb.uq.edu.au)
% Date: 2025-5

% --- DESCRIPTION: 
% This code uses the nematic orientation field on 3D surfaces, performs 
% coarse-graining, calculates the local nematic order parameter, and  
% detects nematic topological defects.

% --- INPUT:
% MATLAB ... Nematic analysis on the surface 
% output of pre-analysis file: Analysis_Surface_Nematic.mat (i.e. generated by Slicing_Nematic.m)

% nematic director analysis per surface point, k_point:
% Nematic(k_point).xyz_director_pos         ... xyz position of surface points, in um
% Nematic(k_point).xyz_normal_vector        ... xyz normal vectors
% Nematic(k_point).theta                    ... theta angle of plane, in degree
% Nematic(k_point).phi                      ... phi angle of plane, in degree
% Nematic(k_point).Nematic_director_comp    ... 2D complex nematic order 
% Nematic(k_point).xy_Nematic_director      ... xy nematic director 

% plane analysis:
% Properties.x_system_center                ... x cell system center point, in um
% Properties.y_system_center                ... y cell system center point, in um
% Properties.z_system_center                ... z cell system center point, in um
% Properties.grid_dis_3D                    ... distance between xyz
%                                               surface points, in um
% Properties.range_tangent_planes           ... distance of plane to surface, in um
% Properties.coarse_graining_range          ... coarse-graining
%                                               range n*W = n*d_P/2 (see manuscript, Eq.(4))


% chose if defects should be analyzed, 0: no, 1: yes 
analysis_defects = 1;   

% chose if system is a sphere, 1: yes, 0: no for arbitrary geometry 
analysis_sphere = 0;

% scale factor for visualizing nematic directors 
scale_factor = 3; 

% coarse_graining factor where r = cg_range * surface point distance
cg_range = 1.7;   


% --- OUTPUT:
% save as Analysis_Coarse_Grained_Nematic.mat
% CoarseGrainedNematic.Nematic_Director              ... xyz coarse-grained nematic director
% CoarseGrainedNematic.Local_Order                   ... local nematic order parameter
%                                                        of coarse-grained director field
% CoarseGrainedNematic.Coarse_Graining_radius        ... coarse-grained radius, in um
% CoarseGrainedNematic.Coarse_Graining_number_points ... local number of surface points for coarse-graining

% save as Analysis_Defects.mat
% Defects.xyz_Defect_Charge                          ... xyz defect position, in um
% Defects.Defect_Charge                              ... defect charge    


%..........................................................................
%........................ Main ............................................
%..........................................................................

% ... load parameters for the analysis ....................................

load('Analysis_Surface_Nematic.mat') 
if isempty(Properties.x_system_center) == 1
    disp('Analysis_Surface_Nematic.mat does not exist');
end

if analysis_sphere == 1
    load('SurfacePointsSphere.mat')
    if isempty(SurfacePoints.xyz) == 1
        disp('SurfacePointsSphere.mat does not exist');
    end
end 



% ... import and pre-process data ........................................

xyz_pos = [];
xy_director = [];
director = [];
normal_vector = [];
Angle_phi = [];
Angle_theta = [];
for k = 1:size(Nematic,2)
    xyz_pos = [xyz_pos; Nematic(k).xyz_director_pos];
    xy_director = [xy_director; Nematic(k).xy_Nematic_director];
    director = [director; Nematic(k).Nematic_director_comp];
    normal_vector = [normal_vector; Nematic(k).xyz_normal_vector];
    Angle_phi = [Angle_phi; Nematic(k).phi];
    Angle_theta = [Angle_theta; Nematic(k).theta];
end

% convert angles from degree to radiant 
ap_a = Angle_phi*pi/180;
at_a = Angle_theta*pi/180;

x_system_center = Properties.x_system_center;
y_system_center = Properties.y_system_center;
z_system_center = Properties.z_system_center;


if analysis_sphere == 1
    % for coarse-graining on spheres, estimate surface point distance 
    r = SurfacePoints.SphereRadius;
    nx = SurfacePoints.SphereN;
    f = icosphere(nx);
    faces_rec = f.Faces;
    xyz_p = f.Vertices;
    pp_dis = [];
    for k = 1:length(faces_rec(:,1))
        pp_dis = [pp_dis; norm(xyz_rec(faces_p(k,1),:)-xyz_p(faces_rec(k,2),:))*r];
    end
    dis_point = mean(pp_dis);
else 
    dis_point = Properties.grid_dis_3D;
end


% ... Get coarse-grained 3D nematic director ..............................

% create 3D nematic directors, being tangential to the ...
% ... surface, and calculate rank-2 tensor
QT = cell(length(xy_director(:,1)),1);
for k = 1:length(xy_director(:,1))

    % 3D nematic director, see Eq.(7-9)
    e_phi = [cos(ap_a(k)), sin(ap_a(k)), 0];
    e_theta = [-cos(at_a(k))*sin(ap_a(k)),...
                cos(at_a(k))*cos(ap_a(k)),...
                sin(at_a(k))];
    U = xy_director(k,1)*e_phi+xy_director(k,2)*e_theta;

    % rank-2 tensor, see Eq.(10)
    UU = [U(1)*U(1), U(1)*U(2), U(1)*U(3); ...
          U(2)*U(1), U(2)*U(2), U(2)*U(3); ...
          U(3)*U(1), U(3)*U(2), U(3)*U(3)];
    DD = [1, 0, 0; 0, 1, 0; 0, 0, 1];
    QT{k,1} = 1/2*(3*UU-DD);
end

% coarse-grain tensors and get 3D nematic directors ...
% ... (eigenvectors of tensor), see Eq.(11)
Q_director = [];
CG_point_number  = [];
for j = 1:length(xyz_pos(:,1))

    % search for nematic directors within a radius of dis_point*cg_range
    Idx = rangesearch(xyz_pos, xyz_pos(j,:), dis_point*cg_range);

    CG_point_number = [CG_point_number; length(Idx{1,1})];
    
    % calculate mean of tensors 
    QQ = zeros(3,3);
    QQ_length = [];
    for k = 1:length(Idx{1,1})
        if isnan(QT{Idx{1,1}(k),1}(1,1)) == 0
            QQ = QQ+QT{Idx{1,1}(k),1};
            QQ_length = [QQ_length; k];
        end   
    end
    [V,D] = eig(QQ/length(QQ_length));

    % eigenvector of tensor = nematic director
    Q_director = [Q_director; V(:,3)'];
end


% ................ 3D nematic orientation field and defects ...............

defect_charge = [];
Q_order = [];
for j = 1:length(xyz_pos(:,1))

    % search for coarse-grained nematic directors within a radius ...
    % ... of dis_point*1.7 for nearest neighbors only     
    idx_v = rangesearch(xyz_pos,xyz_pos(j,:),dis_point*1.7);
    idx_v = idx_v{1,1};

    % get local order parameter of coarse-grained nematic directors 
    QT2 = zeros(3,3);
    for k = 1:length(idx_v)
        U = Q_director(idx_v(k),:);    
        UU = [U(1)*U(1), U(1)*U(2), U(1)*U(3); ...
              U(2)*U(1), U(2)*U(2), U(2)*U(3); ...
              U(3)*U(1), U(3)*U(2), U(3)*U(3)];
        DD = [1, 0, 0; 0, 1, 0; 0, 0, 1];
        QT2 = QT2 + 1/2*(3*UU-DD);
    end

    [V,D] = eig(QT2/length(idx_v));
    % eigenvalue of tensor = order parameter
    Q_order = [Q_order; D(3,3)];


% ... Determine nematic topological defects ...............................

    % local nematic directors 
    idx_v = rangesearch(xyz_pos,xyz_pos(j,:),dis_point*1.7); 
    idx_v = idx_v{1,1};

    if analysis_defects ==  1
        % remove centered nematic director for defect analysis
        idx_v = setdiff(idx_v,j);
        if length(idx_v) > 2
    
            % sort local xyz surface points counter clockwise
            xyz_sp = xyz_pos(idx_v',:);
            xyz_center = xyz_pos(j,:);
            P = xyz_sp - xyz_center;
            [~,~,V] = svd(P,0);
            [~,idx_orm] = sort(atan2(P*V(:,1),P*V(:,2)));
        
            % check for clockwise distribution with respect to normal vector 
            u = cross(P(idx_orm(2),:),P(idx_orm(1),:))/norm(cross(P(idx_orm(2),:),P(idx_orm(1),:)));
            v = normal_vector(j,:);
            angle_norm_vecs = atan2(norm(cross(u,v)), dot(u,v));
            if abs(angle_norm_vecs) > pi/2
                idx_or = idx_orm;
            else
                % flip order to counter clockwise
                idx_or = flip(idx_orm);
            end
        
            % list of nematic directors for winding number calculation
            list_directors = Q_director(idx_v(idx_or),:);
            list_directors = [list_directors; list_directors(1,:)];
            
            % angle difference between neighboring directors
            delta_angle = [];
            for jj = 1:length(list_directors(:,1))-1
        
                % normal vector of surface plane at surface point 
                n_SP = normal_vector(j,:);
                
                % projected 3D directors on 2D surface plane to get 2D director
                plane_director1 = (dot(list_directors(jj,:),n_SP)/(norm(n_SP)^2))*n_SP';
                plane_director1 = list_directors(jj,:)'-plane_director1;
                plane_director2 = (dot(list_directors(jj+1,:),n_SP)/(norm(n_SP)^2))*n_SP';
                plane_director2 = list_directors(jj+1,:)'-plane_director2;
        
                kvec = [0; 0; 1];
                udot = dot(n_SP, kvec)/(norm(n_SP));
                % angle of plane to x-y
                ang_plane = acos(udot); 
                uv = cross(n_SP, kvec)/(norm(cross(n_SP, kvec)));
        
                if norm(cross(n_SP, kvec)) == 0
                else
                    % rotations matrix to xy plane !!!
                    RotM = [cos(ang_plane)+uv(1)^2*(1-cos(ang_plane)), uv(1)*uv(2)*(1-cos(ang_plane)), uv(2)*sin(ang_plane);...
                         uv(1)*uv(2)*(1-cos(ang_plane)), cos(ang_plane)+uv(2)^2*(1-cos(ang_plane)), -uv(1)*sin(ang_plane);...
                         -uv(2)*sin(ang_plane), uv(1)*sin(ang_plane), cos(ang_plane)];
        
                    % rotate on plane projected directors to xy-plane
                    plane_director1 = RotM*plane_director1;
                    plane_director2 = RotM*plane_director2;
                end
                plane_angle1 = atan(plane_director1(2)/plane_director1(1));
                plane_angle2 = atan(plane_director2(2)/plane_director2(1));
                
                % angle difference 
                angle_dif = (plane_angle2-plane_angle1);
        
                % winding number
                if angle_dif > pi/2
                    angle_dif = angle_dif - 2*pi/2;
                end
                if angle_dif < -pi/2
                    angle_dif = angle_dif + 2*pi/2;
                end
        
                delta_angle = [delta_angle; angle_dif];
        
            end
        
            % calculate defect charge
            DC = nansum(delta_angle)/(2*pi);
            defect_charge = [defect_charge; DC];
            
%             % xyz surface point = potential defect position 
%             XY = xyz_pos(j,:);
%         
%             % plot defects 
%             if DC < -0.8 && DC > -1.2 %-1
%             plot3(XY(1)-x_system_center, XY(2)-y_system_center,XY(3)-z_system_center,'o', 'color',[0 0.4470 0.7410], 'MarkerSize', 10, 'LineWidth', 2)
%             end
%             if DC < -0.3 && DC > -0.7 %-1/2
%             plot3(XY(1)-x_system_center, XY(2)-y_system_center,XY(3)-z_system_center, 'o','color',[0.3010 0.7450 0.9330], 'MarkerSize', 10, 'LineWidth', 2)
%             end
%             if DC < 0.7 && DC > 0.3 %+1/2
%             plot3(XY(1)-x_system_center, XY(2)-y_system_center,XY(3)-z_system_center,'o', 'color',[0.8500 0.3250 0.0980], 'MarkerSize', 10, 'LineWidth', 2)
%             end
%             if DC < 1.2 && DC > 0.8 %+1
%             plot3(XY(1)-x_system_center, XY(2)-y_system_center,XY(3)-z_system_center,'o', 'color',[0.6350 0.0780 0.1840], 'MarkerSize', 10, 'LineWidth', 2)
%             end
    
        else
            defect_charge = [defect_charge; 0];
        end
    end
end


% ... average over nearby defects ..........................................

if analysis_defects == 1
    % sort defects according to their charge
    [kp,~] = find(defect_charge > 0.4);
    [kn,~] = find(defect_charge < -0.4);
    kall = [kn; kp];
    
    xyz_pos_mean = [];
    DC_mean = [];
    
    % positive charges 
    nn = 0;
    for kh = 1:length(kp(:,1))
    
        % find positive defects within a radius of dis_point*cg_range
        idx_v = rangesearch(xyz_pos(kp,:),xyz_pos(kp(kh),:),dis_point*1.9); 
        idx_v = idx_v{1,1};
    
        kp_idx = kp(idx_v); 
        kp_idx_unique = unique(kp_idx);
    
        for kt = 1:length(nn)
             kp_idx_unique(kp_idx_unique==nn(kt)) = [];
        end
    
        if length(kp_idx_unique)>0
            dhh = defect_charge(kp_idx_unique,:);
            testsum = abs(length(dhh(dhh>0))-length(dhh(dhh<0)));
            if testsum == 0
            else
                if length(kp_idx_unique) > 1
                    xyz_pos_mean = [xyz_pos_mean; nanmean(xyz_pos(kp_idx_unique,:))];
                else
                    xyz_pos_mean = [xyz_pos_mean; xyz_pos(kp_idx_unique,:)];
                end
                DC_mean = [DC_mean; nansum(dhh)/abs(length(dhh(dhh>0))-length(dhh(dhh<0)))];
            end
        end
        nn = [nn; kp_idx_unique];
    
    end
    
    % negative charges 
    nn = 0;
    for kh = 1:length(kn(:,1))
    
        % find negative defects within a radius of dis_point*cg_range
        idx_v = rangesearch(xyz_pos(kn,:),xyz_pos(kn(kh),:),dis_point*1.9);
        idx_v = idx_v{1,1};
    
        kn_idx = kn(idx_v); % changes surrounding charge
        kn_idx_unique = unique(kn_idx);
    
        for kt = 1:length(nn)
             kn_idx_unique(kn_idx_unique==nn(kt)) = [];
        end
    
        if length(kn_idx_unique)>0
            dhh = defect_charge(kn_idx_unique,:);
            testsum = abs(length(dhh(dhh>0))-length(dhh(dhh<0)));
            if testsum == 0
            else
                if length(kn_idx_unique) > 1
                    xyz_pos_mean = [xyz_pos_mean; nanmean(xyz_pos(kn_idx_unique,:))];
                else
                    xyz_pos_mean = [xyz_pos_mean; xyz_pos(kn_idx_unique,:)];
                end
                DC_mean = [DC_mean; nansum(dhh)/abs(length(dhh(dhh>0))-length(dhh(dhh<0)))];
            end
        end
        nn = [nn; kn_idx_unique];
    
    end
    
    % find unique elements 
    [~,ind_unique,~] = unique(xyz_pos_mean,'rows');
    
    xyz_pos_mean_uniq = xyz_pos_mean(ind_unique,:);
    DC_mean_uniq = DC_mean(ind_unique);
end

CoarseGrainedNematic = [];
CoarseGrainedNematic.Nematic_Director = Q_director;                 % xyz coarse-grained nematic director
CoarseGrainedNematic.Local_Order = Q_order;                         % local nematic order parameter ...
                                                                    % ... of coarse-grained director field
CoarseGrainedNematic.Coarse_Graining_radius = dis_point*cg_range;   % coarse-grained radius, in um
CoarseGrainedNematic.Coarse_Graining_number_points = CG_point_number; % local number of surface points for coarse-graining
save(['Analysis_Coarse_Grained_Nematic.mat'],'CoarseGrainedNematic','-double')

if analysis_defects == 1 
    Defects  = [];
    Defects.xyz_Defect_Charge = xyz_pos_mean_uniq;              % xyz defect position, in um
    Defects.Defect_Charge = DC_mean_uniq;                       % defect charge    
    save(['Analysis_Defects.mat'],'Defects','-double')
end

close all
clear all






