
clear all

% ......................................................................
% ......... Fluorenscent Signal Detection of 3D Surfaces ...............
% ......................................................................

% Author: Julia Eckert (j.eckert@imb.uq.edu.au)
% Date: 2025-5

% --- DESCRIPTION: 
% This code performs the 3D surface analysis via slicing the systems 
% surface by shallow slices, i.e. translated tangent planes, and obtains 
% the intensity signals of fluorescence reporters.

% --- TO DO: 
% ImageJ/Fiji
%   Image for fluorescence analysis
%       - do not pre-process the image as eplained in REF
%       - inverte z-stack (background = white) 
%       - save z-stack as 'Marker_X.tif'

% --- INPUT:
% MATLAB ... output of pre-analysis file: SurfacePoints.mat (i.e. generated by Surface_Points.m)
%   SurfacePoints.xyz           ... xyz surface point position on surface, in um 
%   SurfacePoints.xyzNormal     ... xyz normal vector on surface 
%   SurfacePoints.Pixel         ... xyz um / pixel information of z-stack
%   SurfacePoints.GridDistance  ... xyz surface point distance, in um
% Images z-stack as TIF-format
%   Marker_X.tif                ... z-stack of fluorescence channel
%   Mask_Boundary.tif           ... z-stack of black-and-white mask

% intensity average over x planes tanslated towards the bulk ... 
% ... 0 corresponds to the tangent plane at the surface point, in um 
no_tang_plane = [0:1:3]; % Zebrafish heart

% radius to average the intensity signal: radius = r_bin * d_P ... 
% ... with d_P the distance between xyz surface points, in um 
r_bin = 0.5;         


% --- OUTPUT:
% save as Analysis_Surface_Marker_X.mat

% Background signal of n surface points
% X_Intensity.Bkg_max                ... (n,1) median, (n,2) mean, (n,3) sd of max-projected signal  
% X_Intensity.Bkg_sum                ... (n,1) median, (n,2) mean, (n,3) sd of sum-projected signal  
% X_Intensity.Bkg_mean               ... (n,1) median, (n,2) mean, (n,3) sd of mean-projected signal 

% Fluorescence signal within a radius of half the xyz surface point ...
% ... distance of n surface points
% X_Intensity.max_projection_mean    ... (n,1) median, (n,2) mean, (n,3) sd of max-projected signal 
% X_Intensity.sum_projection_mean    ... (n,1) median, (n,2) mean, (n,3) sd of sum-projected signal 
% X_Intensity.mean_projection_mean   ... (n,1) median, (n,2) mean, (n,3) sd of mean-projected signal 
% X_Intensity.radius                 ... radius of region of interest, in um

% plane anaysis:
% Properties.x_system_center                ... x cell system center point, in um
% Properties.y_system_center                ... y cell system center point, in um
% Properties.z_system_center                ... z cell system center point, in um
% Properties.grid_dis_3D                    ... xyz distance between
%                                               surface points, in um
% Properties.range_tangent_planes           ... plane positions, in um
% Properties.coarse_graining_range          ... intager of coarse-graining
%                                               range n*W = n*d_P/2 (see manuscript, Eq.(4))


%..........................................................................
%........................ Main ............................................
%..........................................................................

% suppresses graphical output, speeds up the analysis
%set(0,'DefaultFigureVisible','off')

% ... Upload images .......................................................
image_x = tiffreadVolume('Marker_X.tif'); % see (1) above
image_mask = tiffreadVolume('Mask_Boundary.tif'); 


% ... load information of surface points and normal vectors ..............
load('SurfacePoints.mat')
if isempty(SurfacePoints.Pixel) == 1
    disp('SurfacePoints.mat does not exist');
end
xyz_pos = SurfacePoints.xyz;              %... xyz position of surface points, in um
xyz_normal_vec = SurfacePoints.xyzNormal; %... xyz normal vectors
xyz = SurfacePoints.Pixel;                %... dimension of z-stack, um/pix
grid_dis_3D = SurfacePoints.GridDistance; %... distance between xyz surface points, in um


% ... Set parameters for analysis ... can be adjusted ..................... 

% grid distance of nematic director on 2D plane, pre-set to half of the 3D
% grid distance, in um
grid_distance = grid_dis_3D/2; 

% plane radius in um ... size: plane_r*2 x plane_r*2, in um
plane_r = 50; 

% window size for averaging the orientation-output of OrientationJ, in pix
window_size = grid_distance/(2*plane_r/1000); % in pix (= grid_distance / 2*plane_r/1000 um/um/pix)

% window of overlap for nematic director calculation, in pix 
ol = window_size/4; 

% length nematic director, in pix
scale_factor = window_size/2;


% ... Get dimensions for xyz plane ........................................ 

% create xyz meshgrid for spheroid slicing 
xlin = 0:xyz(2):size(image_mask,2)*xyz(2)-xyz(2);
ylin = 0:xyz(1):size(image_mask,1)*xyz(1)-xyz(1);
zlin = 0:xyz(3):size(image_mask,3)*xyz(3)-xyz(3);
[xdata, ydata, zdata] = meshgrid(xlin,ylin,zlin);

% dimensions of meshgrid data 
xmin = min(xdata(:));
xmax = max(xdata(:));
ymin = min(ydata(:));
ymax = max(ydata(:));
zmin = min(zdata(:));
zmax = max(zdata(:));


% ... Pre-process stack and get properties of the cell system .............

% z-stack of fluorescence channel
vdatax = double(image_x);

% background of fluorescence channel ... baclground noise
image_bkg_x = double(image_x);
image_bkg_x(image_mask==255) = NaN;
vdata_bkg_x = image_bkg_x;    

% get center of mass of cell system
sm  = regionprops(bwconncomp(imfill(image_mask(:,:,round(size(image_mask,3)/2)),'holes'),8),'Area','FilledArea','FilledImage','Centroid','MajorAxisLength',...
   'MinorAxisLength', 'Perimeter','Orientation','Eccentricity','PixelIdxList','PixelList');

centroids_=[sm.Centroid];
centroids_=[centroids_(1:2:end)',centroids_(2:2:end)'];

areas_ = [sm.Area];
idx_area = find(areas_==max(areas_));

% xyz center point of cell system in um
x_sphere_center = centroids_(idx_area,1)*xyz(1);
y_sphere_center = centroids_(idx_area,2)*xyz(2);
z_sphere_center = zmax/2;


% ... Slice cell system at each surface point and get nematic order ...........

X_Intensity = [];
max_projection_mean = [];
sum_projection_mean = [];
mean_projection_mean = [];
Bkg_max = [];
Bkg_sum = [];
Bkg_mean = [];

% slice cell system point-by-point
for k_point = 1:length(xyz_pos(:,1))    

    disp([num2str(k_point), ' of ', num2str(length(xyz_pos(:,1)))]);

    % normalize normal surface vector 
    nnP = xyz_normal_vec(k_point,:);
    nP = nnP/norm(nnP);
    nx = nP(1);
    ny = nP(2);
    nz = nP(3); 

    % xyz position of surface point
    P_mean = xyz_pos(k_point,:);

    % calculate angle between normal vector and z-axis -> theta, ...
    % ... see manuscript Eq.(1)
    tt = atan2d(norm(cross([nx(1),ny(1),nz(1)]',[0,0,1]')), ...
            dot([nx(1),ny(1),nz(1)]',[0,0,1]')); % angle to z-axis
    % Theta in degree for regression plane
    at = -tt;

    % calculate angle between normal vector and xy plane -> phi, ...
    % ... see manuscript Eq.(2)
    tp = -atan2d(ny,nx);
    % Phi in degree for regression plane
    ap = -tp-90;


   % create tangent plane with dimensions ... 1 pix = 2*plane_r/1000 um
    figure
    hold on
    hslice = surf(linspace(-plane_r,plane_r,1000), linspace(-plane_r,plane_r,1000), zeros(1000));
 
    rotate(hslice,[1, 0, 0],at,[0 0 0])
    rotate(hslice,[0, 0, 1],ap,[0 0 0])
    
    % max-project and sum surface planes of cell system and background seperatly 
    im_slice_max_x = zeros(1000,1000);
    im_slice_sum_x = zeros(1000,1000);
    im_slice_max_bkg_x = NaN(1000,1000);
    im_slice_sum_bkg_x = NaN(1000,1000);
    for ct = 1:length(no_tang_plane)
    % move plane by rk towards center, in um
        rk = no_tang_plane(ct); 
        xd = get(hslice,'XData')+P_mean(1)-x_sphere_center-rk*nx(1);
        yd = get(hslice,'YData')+P_mean(2)-y_sphere_center-rk*ny(1);
        zd = get(hslice,'ZData')+P_mean(3)-z_sphere_center-rk*nz(1);
    
        figure, hold on
        h_x = slice(xdata-x_sphere_center, ydata-y_sphere_center, zdata-z_sphere_center, vdatax, xd, yd, zd);

        h_bkg_x = slice(xdata-x_sphere_center, ydata-y_sphere_center, zdata-z_sphere_center, vdata_bkg_x, xd, yd, zd);

        % get plane data of cell system (max and sum)
        im_slice_x = h_x.CData;   
        im_slice_x(isnan(im_slice_x)) = 0;

        im_slice_max_x = max(im_slice_max_x, im_slice_x);
        im_slice_sum_x = im_slice_sum_x + im_slice_x;
        
        % get plane data of background and ignore NaNs (max)
        im_slice_bkg_x = h_bkg_x.CData;
        im_slice_max_bkg_x(isnan(im_slice_bkg_x)) = NaN;
        im_slice_max_bkg_x = max(im_slice_max_bkg_x, im_slice_bkg_x);

        % get plane data of background and ignore NaNs (sum)
        im_slice_sum_bkg_x(isnan(im_slice_bkg_x)) = NaN;
        tmp = cat(3,im_slice_sum_bkg_x,im_slice_bkg_x);
        im_slice_sum_bkg_x = nansum(tmp,3);

    end

    % center point of plane, in um
     x = size(im_slice_x,1)/2;
     y = size(im_slice_x,2)/2;

    bmax = im_slice_max_bkg_x(:);
    bsum = im_slice_sum_bkg_x(:);

    % median, mean, and sd of max-, sum-, and median projected background ...
    % ... signal of each generated image
    Bkg_max = [Bkg_max; nanmedian(bmax(bmax>0)), nanmean(bmax(bmax>0)), nanstd(bmax(bmax>0))];
    Bkg_sum = [Bkg_sum; nanmedian(bsum(bsum>0)), nanmean(bsum(bsum>0)), nanstd(bsum(bsum>0))];
    Bkg_mean = [Bkg_mean; nanmedian(bsum(bsum>0)/length(no_tang_plane)), nanmean(bsum(bsum>0)/length(no_tang_plane)), nanstd(bsum(bsum>0)/length(no_tang_plane))];

    % only consider intensity signals within a radius of half the ...
    % ... xyz surface point distance
    temp_mask = zeros(size(im_slice_max_x,1),size(im_slice_max_x,2));
    temp_mask(round(x), round(y)) = 1;
    seD = strel('disk',r_bin*window_size*2);
    temp_mask_dil = imdilate(temp_mask,seD);
    im_slice_max_x(temp_mask_dil==0) = NaN;
    im_slice_sum_x(temp_mask_dil==0) = NaN;

    % mean and sd of max-, sum-, and median projected signal of each ... generated image 
    max_projection_mean = [max_projection_mean; nanmean(im_slice_max_x(:)), nanstd(im_slice_max_x(:))];
    sum_projection_mean = [sum_projection_mean; nanmean(im_slice_sum_x(:)), nanstd(im_slice_sum_x(:))];
    mean_projection_mean = [mean_projection_mean; nanmean(im_slice_sum_x(:)/length(no_tang_plane)), nanstd(im_slice_sum_x(:)/length(no_tang_plane))];

    close all
end

% Background
X_Intensity.Bkg_max = Bkg_max;                          % (n,1) median, (n,2) mean, (n,3) sd of max-projected signal  
X_Intensity.Bkg_sum = Bkg_sum;                          % (n,1) median, (n,2) mean, (n,3) sd of sum-projected signal  
X_Intensity.Bkg_mean = Bkg_mean;                        % (n,1) median, (n,2) mean, (n,3) sd of mean-projected signal 

% Fluorescence signal within a radius of half the xyz surface point distance
X_Intensity.max_projection_mean = max_projection_mean;  % (n,1) median, (n,2) mean, (n,3) sd of max-projected signal 
X_Intensity.sum_projection_mean = sum_projection_mean;  % (n,1) median, (n,2) mean, (n,3) sd of sum-projected signal 
X_Intensity.mean_projection_mean = mean_projection_mean;% (n,1) median, (n,2) mean, (n,3) sd of mean-projected signal 
X_Intensity.radius = grid_distance;                     % radius of region of interest in um

X_Properties.x_system_center = x_sphere_center;    % x cell system center point, in um
X_Properties.y_system_center = y_sphere_center;    % y cell system center point, in um
X_Properties.z_system_center = z_sphere_center;    % z cell system center point, in um
X_Properties.grid_dis_3D = grid_dis_3D;            % xyz distance between surface points, in um
X_Properties.range_tangent_planes = no_tang_plane; % plane positions, in um

save(['Analysis_Surface_Marker_X.mat'],'X_Intensity','X_Properties','-double')

set(0,'DefaultFigureVisible','on')

close all
clear all
